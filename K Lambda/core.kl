"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V560 V561) (compile (lambda V553 (shen.<define> V553)) (cons V560 V561) (lambda X (shen.shen-syntax-error V560 X))))

(defun shen.shen-syntax-error (V562 V563) (simple-error (cn "syntax error in " (shen.app V562 (cn " here:

 " (shen.app (shen.next-50 50 V563) "
" shen.a)) shen.a))))

(defun shen.<define> (V564) (let YaccParse (let Parse_shen.<name> (shen.<name> V564) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V564) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V565) (if (cons? (hd V565)) (let Parse_X (hd (hd V565)) (shen.pair (hd (shen.pair (tl (hd V565)) (shen.hdtl V565))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V566) (element? V566 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V567) (if (and (cons? (hd V567)) (= { (hd (hd V567)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V567)) (shen.hdtl V567))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V568) (cond ((and (cons? V568) (and (cons? (tl V568)) (and (= --> (hd (tl V568))) (and (cons? (tl (tl V568))) (and (cons? (tl (tl (tl V568)))) (= --> (hd (tl (tl (tl V568)))))))))) (shen.curry-type (cons (hd V568) (cons --> (cons (tl (tl V568)) ()))))) ((and (cons? V568) (and (cons? (tl V568)) (and (= * (hd (tl V568))) (and (cons? (tl (tl V568))) (and (cons? (tl (tl (tl V568)))) (= * (hd (tl (tl (tl V568)))))))))) (shen.curry-type (cons (hd V568) (cons * (cons (tl (tl V568)) ()))))) ((cons? V568) (map (lambda V554 (shen.curry-type V554)) V568)) (true V568)))

(defun shen.<signature-help> (V569) (let YaccParse (if (cons? (hd V569)) (let Parse_X (hd (hd V569)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V569)) (shen.hdtl V569))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V569) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V570) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V570) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V570) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V571) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V571) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V571) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V571) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V571) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V572 V573) (if (V572 V573) (fail) V573))

(defun shen.succeeds? (V578) (cond ((= V578 (fail)) false) (true true)))

(defun shen.<patterns> (V579) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V579) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V579) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V585) (let YaccParse (if (and (cons? (hd V585)) (cons? (hd (hd V585)))) (if (and (cons? (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (= @p (hd (hd (shen.pair (hd (hd V585)) (hd (tl V585))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (shen.hdtl (shen.pair (hd (hd V585)) (hd (tl V585)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V585)) (hd (tl V585)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V585)) (cons? (hd (hd V585)))) (if (and (cons? (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (= cons (hd (hd (shen.pair (hd (hd V585)) (hd (tl V585))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (shen.hdtl (shen.pair (hd (hd V585)) (hd (tl V585)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V585)) (hd (tl V585)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V585)) (cons? (hd (hd V585)))) (if (and (cons? (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (= @v (hd (hd (shen.pair (hd (hd V585)) (hd (tl V585))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (shen.hdtl (shen.pair (hd (hd V585)) (hd (tl V585)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V585)) (hd (tl V585)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V585)) (cons? (hd (hd V585)))) (if (and (cons? (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (= @s (hd (hd (shen.pair (hd (hd V585)) (hd (tl V585))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (shen.hdtl (shen.pair (hd (hd V585)) (hd (tl V585)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V585)) (hd (tl V585)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V585)) (cons? (hd (hd V585)))) (if (and (cons? (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (= vector (hd (hd (shen.pair (hd (hd V585)) (hd (tl V585))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (shen.hdtl (shen.pair (hd (hd V585)) (hd (tl V585))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V585)) (hd (tl V585))))) (shen.hdtl (shen.pair (hd (hd V585)) (hd (tl V585))))))))) (shen.pair (hd (shen.pair (tl (hd V585)) (hd (tl V585)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V585)) (let Parse_X (hd (hd V585)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V585)) (shen.hdtl V585))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V585) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V586) (simple-error (shen.app V586 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V587) (let YaccParse (if (cons? (hd V587)) (let Parse_X (hd (hd V587)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V587)) (shen.hdtl V587))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V587)) (let Parse_X (hd (hd V587)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V587)) (shen.hdtl V587))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V588) (let Parse_shen.<pattern> (shen.<pattern> V588) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V589) (let Parse_shen.<pattern> (shen.<pattern> V589) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V590) (if (cons? (hd V590)) (let Parse_X (hd (hd V590)) (shen.pair (hd (shen.pair (tl (hd V590)) (shen.hdtl V590))) Parse_X)) (fail)))

(defun shen.<guard> (V591) (if (cons? (hd V591)) (let Parse_X (hd (hd V591)) (shen.pair (hd (shen.pair (tl (hd V591)) (shen.hdtl V591))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V592 V593) (let Lambda+ (shen.compile_to_lambda+ V592 V593) (let KL (shen.compile_to_kl V592 Lambda+) (let Record (shen.record-source V592 KL) KL))))

(defun shen.record-source (V596 V597) (cond ((value shen.*installing-kl*) shen.skip) (true (put V596 shen.source V597 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V598 V599) (let Arity (shen.aritycheck V598 V599) (let Free (map (lambda Rule (shen.free_variable_check V598 Rule)) V599) (let Variables (shen.parameters Arity) (let Strip (map (lambda V555 (shen.strip-protect V555)) V599) (let Abstractions (map (lambda V556 (shen.abstract_rule V556)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ())))))))))

(defun shen.free_variable_check (V600 V601) (cond ((and (cons? V601) (and (cons? (tl V601)) (= () (tl (tl V601))))) (let Bound (shen.extract_vars (hd V601)) (let Free (shen.extract_free_vars Bound (hd (tl V601))) (shen.free_variable_warnings V600 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V602) (cond ((variable? V602) (cons V602 ())) ((cons? V602) (union (shen.extract_vars (hd V602)) (shen.extract_vars (tl V602)))) (true ())))

(defun shen.extract_free_vars (V612 V613) (cond ((and (cons? V613) (and (cons? (tl V613)) (and (= () (tl (tl V613))) (= (hd V613) protect)))) ()) ((and (variable? V613) (not (element? V613 V612))) (cons V613 ())) ((and (cons? V613) (and (= lambda (hd V613)) (and (cons? (tl V613)) (and (cons? (tl (tl V613))) (= () (tl (tl (tl V613)))))))) (shen.extract_free_vars (cons (hd (tl V613)) V612) (hd (tl (tl V613))))) ((and (cons? V613) (and (= let (hd V613)) (and (cons? (tl V613)) (and (cons? (tl (tl V613))) (and (cons? (tl (tl (tl V613)))) (= () (tl (tl (tl (tl V613)))))))))) (union (shen.extract_free_vars V612 (hd (tl (tl V613)))) (shen.extract_free_vars (cons (hd (tl V613)) V612) (hd (tl (tl (tl V613))))))) ((cons? V613) (union (shen.extract_free_vars V612 (hd V613)) (shen.extract_free_vars V612 (tl V613)))) (true ())))

(defun shen.free_variable_warnings (V616 V617) (cond ((= () V617) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V616 (cn ": " (shen.app (shen.list_variables V617) "" shen.a)) shen.a))))))

(defun shen.list_variables (V618) (cond ((and (cons? V618) (= () (tl V618))) (cn (str (hd V618)) ".")) ((cons? V618) (cn (str (hd V618)) (cn ", " (shen.list_variables (tl V618))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V619) (cond ((and (cons? V619) (and (cons? (tl V619)) (and (= () (tl (tl V619))) (= (hd V619) protect)))) (shen.strip-protect (hd (tl V619)))) ((cons? V619) (map (lambda V557 (shen.strip-protect V557)) V619)) (true V619)))

(defun shen.linearise (V620) (cond ((and (cons? V620) (and (cons? (tl V620)) (= () (tl (tl V620))))) (shen.linearise_help (shen.flatten (hd V620)) (hd V620) (hd (tl V620)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V621) (cond ((= () V621) ()) ((cons? V621) (append (shen.flatten (hd V621)) (shen.flatten (tl V621)))) (true (cons V621 ()))))

(defun shen.linearise_help (V622 V623 V624) (cond ((= () V622) (cons V623 (cons V624 ()))) ((cons? V622) (if (and (variable? (hd V622)) (element? (hd V622) (tl V622))) (let Var (gensym (hd V622)) (let NewAction (cons where (cons (cons = (cons (hd V622) (cons Var ()))) (cons V624 ()))) (let NewPatts (shen.linearise_X (hd V622) Var V623) (shen.linearise_help (tl V622) NewPatts NewAction)))) (shen.linearise_help (tl V622) V623 V624))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V634 V635 V636) (cond ((= V636 V634) V635) ((cons? V636) (let L (shen.linearise_X V634 V635 (hd V636)) (if (= L (hd V636)) (cons (hd V636) (shen.linearise_X V634 V635 (tl V636))) (cons L (tl V636))))) (true V636)))

(defun shen.aritycheck (V637 V638) (cond ((and (cons? V638) (and (cons? (hd V638)) (and (cons? (tl (hd V638))) (and (= () (tl (tl (hd V638)))) (= () (tl V638)))))) (do (shen.aritycheck-action (hd (tl (hd V638)))) (shen.aritycheck-name V637 (arity V637) (length (hd (hd V638)))))) ((and (cons? V638) (and (cons? (hd V638)) (and (cons? (tl (hd V638))) (and (= () (tl (tl (hd V638)))) (and (cons? (tl V638)) (and (cons? (hd (tl V638))) (and (cons? (tl (hd (tl V638)))) (= () (tl (tl (hd (tl V638)))))))))))) (if (= (length (hd (hd V638))) (length (hd (hd (tl V638))))) (do (shen.aritycheck-action (hd (tl (hd V638)))) (shen.aritycheck V637 (tl V638))) (simple-error (cn "arity error in " (shen.app V637 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V648 V649 V650) (cond ((= -1 V649) V650) ((= V650 V649) V650) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V648 " can cause errors.
" shen.a)) (stoutput)) V650))))

(defun shen.aritycheck-action (V655) (cond ((cons? V655) (do (shen.aah (hd V655) (tl V655)) (map (lambda V558 (shen.aritycheck-action V558)) V655))) (true shen.skip)))

(defun shen.aah (V656 V657) (let Arity (arity V656) (let Len (length V657) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V656 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V658) (cond ((and (cons? V658) (and (cons? (tl V658)) (= () (tl (tl V658))))) (shen.abstraction_build (hd V658) (hd (tl V658)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V659 V660) (cond ((= () V659) V660) ((cons? V659) (cons /. (cons (hd V659) (cons (shen.abstraction_build (tl V659) V660) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V661) (cond ((= 0 V661) ()) (true (cons (gensym V) (shen.parameters (- V661 1))))))

(defun shen.application_build (V662 V663) (cond ((= () V662) V663) ((cons? V662) (shen.application_build (tl V662) (cons V663 (cons (hd V662) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V664 V665) (cond ((and (cons? V665) (and (cons? (tl V665)) (= () (tl (tl V665))))) (let Arity (shen.store-arity V664 (length (hd V665))) (let Reduce (map (lambda V559 (shen.reduce V559)) (hd (tl V665))) (let CondExpression (shen.cond-expression V664 (hd V665) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V664) (hd V665)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V665) TypeTable CondExpression) CondExpression) (let KL (cons defun (cons V664 (cons (hd V665) (cons TypedCondExpression ())))) KL))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V670) (cond ((cons? V670) shen.skip) (true (let FType (assoc V670 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V679 V680) (cond ((and (cons? V679) (and (cons? (tl V679)) (and (= --> (hd (tl V679))) (and (cons? (tl (tl V679))) (and (= () (tl (tl (tl V679)))) (cons? V680)))))) (if (variable? (hd V679)) (shen.typextable (hd (tl (tl V679))) (tl V680)) (cons (cons (hd V680) (hd V679)) (shen.typextable (hd (tl (tl V679))) (tl V680))))) (true ())))

(defun shen.assign-types (V681 V682 V683) (cond ((and (cons? V683) (and (= let (hd V683)) (and (cons? (tl V683)) (and (cons? (tl (tl V683))) (and (cons? (tl (tl (tl V683)))) (= () (tl (tl (tl (tl V683)))))))))) (cons let (cons (hd (tl V683)) (cons (shen.assign-types V681 V682 (hd (tl (tl V683)))) (cons (shen.assign-types (cons (hd (tl V683)) V681) V682 (hd (tl (tl (tl V683))))) ()))))) ((and (cons? V683) (and (= lambda (hd V683)) (and (cons? (tl V683)) (and (cons? (tl (tl V683))) (= () (tl (tl (tl V683)))))))) (cons lambda (cons (hd (tl V683)) (cons (shen.assign-types (cons (hd (tl V683)) V681) V682 (hd (tl (tl V683)))) ())))) ((and (cons? V683) (= cond (hd V683))) (cons cond (map (lambda Y (cons (shen.assign-types V681 V682 (hd Y)) (cons (shen.assign-types V681 V682 (hd (tl Y))) ()))) (tl V683)))) ((cons? V683) (let NewTable (shen.typextable (shen.get-type (hd V683)) (tl V683)) (cons (hd V683) (map (lambda Y (shen.assign-types V681 (append V682 NewTable) Y)) (tl V683))))) (true (let AtomType (assoc V683 V682) (if (cons? AtomType) (cons type (cons V683 (cons (tl AtomType) ()))) (if (element? V683 V681) V683 (shen.atom-type V683)))))))

(defun shen.atom-type (V684) (if (string? V684) (cons type (cons V684 (cons string ()))) (if (number? V684) (cons type (cons V684 (cons number ()))) (if (boolean? V684) (cons type (cons V684 (cons boolean ()))) (if (symbol? V684) (cons type (cons V684 (cons symbol ()))) V684)))))

(defun shen.store-arity (V687 V688) (cond ((value shen.*installing-kl*) shen.skip) (true (put V687 arity V688 (value *property-vector*)))))

(defun shen.reduce (V689) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V689) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V690) (cond ((and (cons? V690) (and (cons? (hd V690)) (and (= /. (hd (hd V690))) (and (cons? (tl (hd V690))) (and (cons? (hd (tl (hd V690)))) (and (= cons (hd (hd (tl (hd V690))))) (and (cons? (tl (hd (tl (hd V690))))) (and (cons? (tl (tl (hd (tl (hd V690)))))) (and (= () (tl (tl (tl (hd (tl (hd V690))))))) (and (cons? (tl (tl (hd V690)))) (and (= () (tl (tl (tl (hd V690))))) (and (cons? (tl V690)) (= () (tl (tl V690))))))))))))))) (do (shen.add_test (cons cons? (tl V690))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V690))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V690)))))) (cons (shen.ebr (hd (tl V690)) (hd (tl (hd V690))) (hd (tl (tl (hd V690))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V690)) ())) (cons (cons tl (tl V690)) ())) (shen.reduce_help Application))))) ((and (cons? V690) (and (cons? (hd V690)) (and (= /. (hd (hd V690))) (and (cons? (tl (hd V690))) (and (cons? (hd (tl (hd V690)))) (and (= @p (hd (hd (tl (hd V690))))) (and (cons? (tl (hd (tl (hd V690))))) (and (cons? (tl (tl (hd (tl (hd V690)))))) (and (= () (tl (tl (tl (hd (tl (hd V690))))))) (and (cons? (tl (tl (hd V690)))) (and (= () (tl (tl (tl (hd V690))))) (and (cons? (tl V690)) (= () (tl (tl V690))))))))))))))) (do (shen.add_test (cons tuple? (tl V690))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V690))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V690)))))) (cons (shen.ebr (hd (tl V690)) (hd (tl (hd V690))) (hd (tl (tl (hd V690))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V690)) ())) (cons (cons snd (tl V690)) ())) (shen.reduce_help Application))))) ((and (cons? V690) (and (cons? (hd V690)) (and (= /. (hd (hd V690))) (and (cons? (tl (hd V690))) (and (cons? (hd (tl (hd V690)))) (and (= @v (hd (hd (tl (hd V690))))) (and (cons? (tl (hd (tl (hd V690))))) (and (cons? (tl (tl (hd (tl (hd V690)))))) (and (= () (tl (tl (tl (hd (tl (hd V690))))))) (and (cons? (tl (tl (hd V690)))) (and (= () (tl (tl (tl (hd V690))))) (and (cons? (tl V690)) (= () (tl (tl V690))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V690))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V690))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V690)))))) (cons (shen.ebr (hd (tl V690)) (hd (tl (hd V690))) (hd (tl (tl (hd V690))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V690)) ())) (cons (cons tlv (tl V690)) ())) (shen.reduce_help Application))))) ((and (cons? V690) (and (cons? (hd V690)) (and (= /. (hd (hd V690))) (and (cons? (tl (hd V690))) (and (cons? (hd (tl (hd V690)))) (and (= @s (hd (hd (tl (hd V690))))) (and (cons? (tl (hd (tl (hd V690))))) (and (cons? (tl (tl (hd (tl (hd V690)))))) (and (= () (tl (tl (tl (hd (tl (hd V690))))))) (and (cons? (tl (tl (hd V690)))) (and (= () (tl (tl (tl (hd V690))))) (and (cons? (tl V690)) (= () (tl (tl V690))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V690))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V690))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V690)))))) (cons (shen.ebr (hd (tl V690)) (hd (tl (hd V690))) (hd (tl (tl (hd V690))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V690)) (cons 0 ()))) ())) (cons (cons tlstr (tl V690)) ())) (shen.reduce_help Application))))) ((and (cons? V690) (and (cons? (hd V690)) (and (= /. (hd (hd V690))) (and (cons? (tl (hd V690))) (and (cons? (tl (tl (hd V690)))) (and (= () (tl (tl (tl (hd V690))))) (and (cons? (tl V690)) (and (= () (tl (tl V690))) (not (variable? (hd (tl (hd V690))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V690))) (tl V690)))) (shen.reduce_help (hd (tl (tl (hd V690))))))) ((and (cons? V690) (and (cons? (hd V690)) (and (= /. (hd (hd V690))) (and (cons? (tl (hd V690))) (and (cons? (tl (tl (hd V690)))) (and (= () (tl (tl (tl (hd V690))))) (and (cons? (tl V690)) (= () (tl (tl V690)))))))))) (shen.reduce_help (shen.ebr (hd (tl V690)) (hd (tl (hd V690))) (hd (tl (tl (hd V690))))))) ((and (cons? V690) (and (= where (hd V690)) (and (cons? (tl V690)) (and (cons? (tl (tl V690))) (= () (tl (tl (tl V690)))))))) (do (shen.add_test (hd (tl V690))) (shen.reduce_help (hd (tl (tl V690)))))) ((and (cons? V690) (and (cons? (tl V690)) (= () (tl (tl V690))))) (let Z (shen.reduce_help (hd V690)) (if (= (hd V690) Z) V690 (shen.reduce_help (cons Z (tl V690)))))) (true V690)))

(defun shen.+string? (V691) (cond ((= "" V691) false) (true (string? V691))))

(defun shen.+vector (V692) (cond ((= V692 (vector 0)) false) (true (vector? V692))))

(defun shen.ebr (V703 V704 V705) (cond ((= V705 V704) V703) ((and (cons? V705) (and (= /. (hd V705)) (and (cons? (tl V705)) (and (cons? (tl (tl V705))) (and (= () (tl (tl (tl V705)))) (> (occurrences V704 (hd (tl V705))) 0)))))) V705) ((and (cons? V705) (and (= let (hd V705)) (and (cons? (tl V705)) (and (cons? (tl (tl V705))) (and (cons? (tl (tl (tl V705)))) (and (= () (tl (tl (tl (tl V705))))) (= (hd (tl V705)) V704))))))) (cons let (cons (hd (tl V705)) (cons (shen.ebr V703 (hd (tl V705)) (hd (tl (tl V705)))) (tl (tl (tl V705))))))) ((cons? V705) (cons (shen.ebr V703 V704 (hd V705)) (shen.ebr V703 V704 (tl V705)))) (true V705)))

(defun shen.add_test (V706) (set shen.*teststack* (cons V706 (value shen.*teststack*))))

(defun shen.cond-expression (V707 V708 V709) (let Err (shen.err-condition V707) (let Cases (shen.case-form V709 Err) (let EncodeChoices (shen.encode-choices Cases V707) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V712) (cond ((and (cons? V712) (and (cons? (hd V712)) (and (= true (hd (hd V712))) (and (cons? (tl (hd V712))) (= () (tl (tl (hd V712)))))))) (hd (tl (hd V712)))) (true (cons cond V712))))

(defun shen.encode-choices (V715 V716) (cond ((= () V715) ()) ((and (cons? V715) (and (cons? (hd V715)) (and (= true (hd (hd V715))) (and (cons? (tl (hd V715))) (and (cons? (hd (tl (hd V715)))) (and (= shen.choicepoint! (hd (hd (tl (hd V715))))) (and (cons? (tl (hd (tl (hd V715))))) (and (= () (tl (tl (hd (tl (hd V715)))))) (and (= () (tl (tl (hd V715)))) (= () (tl V715))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V715))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V716 ())) (cons shen.f_error (cons V716 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V715) (and (cons? (hd V715)) (and (= true (hd (hd V715))) (and (cons? (tl (hd V715))) (and (cons? (hd (tl (hd V715)))) (and (= shen.choicepoint! (hd (hd (tl (hd V715))))) (and (cons? (tl (hd (tl (hd V715))))) (and (= () (tl (tl (hd (tl (hd V715)))))) (= () (tl (tl (hd V715)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V715))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V715) V716)) (cons Result ())))) ())))) ())) ())) ((and (cons? V715) (and (cons? (hd V715)) (and (cons? (tl (hd V715))) (and (cons? (hd (tl (hd V715)))) (and (= shen.choicepoint! (hd (hd (tl (hd V715))))) (and (cons? (tl (hd (tl (hd V715))))) (and (= () (tl (tl (hd (tl (hd V715)))))) (= () (tl (tl (hd V715))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V715) V716)) ())) (cons (cons if (cons (hd (hd V715)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V715))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V715) (and (cons? (hd V715)) (and (cons? (tl (hd V715))) (= () (tl (tl (hd V715))))))) (cons (hd V715) (shen.encode-choices (tl V715) V716))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V721 V722) (cond ((= () V721) (cons V722 ())) ((and (cons? V721) (and (cons? (hd V721)) (and (cons? (hd (hd V721))) (and (= : (hd (hd (hd V721)))) (and (cons? (tl (hd (hd V721)))) (and (= shen.tests (hd (tl (hd (hd V721))))) (and (= () (tl (tl (hd (hd V721))))) (and (cons? (tl (hd V721))) (and (cons? (hd (tl (hd V721)))) (and (= shen.choicepoint! (hd (hd (tl (hd V721))))) (and (cons? (tl (hd (tl (hd V721))))) (and (= () (tl (tl (hd (tl (hd V721)))))) (= () (tl (tl (hd V721)))))))))))))))) (cons (cons true (tl (hd V721))) (shen.case-form (tl V721) V722))) ((and (cons? V721) (and (cons? (hd V721)) (and (cons? (hd (hd V721))) (and (= : (hd (hd (hd V721)))) (and (cons? (tl (hd (hd V721)))) (and (= shen.tests (hd (tl (hd (hd V721))))) (and (= () (tl (tl (hd (hd V721))))) (and (cons? (tl (hd V721))) (= () (tl (tl (hd V721)))))))))))) (cons (cons true (tl (hd V721))) ())) ((and (cons? V721) (and (cons? (hd V721)) (and (cons? (hd (hd V721))) (and (= : (hd (hd (hd V721)))) (and (cons? (tl (hd (hd V721)))) (and (= shen.tests (hd (tl (hd (hd V721))))) (and (cons? (tl (hd V721))) (= () (tl (tl (hd V721))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V721))))) (tl (hd V721))) (shen.case-form (tl V721) V722))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V723) (cond ((and (cons? V723) (= () (tl V723))) (hd V723)) ((cons? V723) (cons and (cons (hd V723) (cons (shen.embed-and (tl V723)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V724) (cons true (cons (cons shen.f_error (cons V724 ())) ())))

(defun shen.sys-error (V725) (simple-error (cn "system function " (shen.app V725 ": unexpected argument
" shen.a))))



