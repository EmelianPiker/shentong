"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V2077 V2078) (let Curry (shen.curry V2077) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2078)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2079) (cond ((and (cons? V2079) (shen.special? (hd V2079))) (cons (hd V2079) (map (lambda V1754 (shen.curry V1754)) (tl V2079)))) ((and (cons? V2079) (and (cons? (tl V2079)) (shen.extraspecial? (hd V2079)))) V2079) ((and (cons? V2079) (and (= type (hd V2079)) (and (cons? (tl V2079)) (and (cons? (tl (tl V2079))) (= () (tl (tl (tl V2079)))))))) (cons type (cons (shen.curry (hd (tl V2079))) (tl (tl V2079))))) ((and (cons? V2079) (and (cons? (tl V2079)) (cons? (tl (tl V2079))))) (shen.curry (cons (cons (hd V2079) (cons (hd (tl V2079)) ())) (tl (tl V2079))))) ((and (cons? V2079) (and (cons? (tl V2079)) (= () (tl (tl V2079))))) (cons (shen.curry (hd V2079)) (cons (shen.curry (hd (tl V2079))) ()))) (true V2079)))

(defun shen.special? (V2080) (element? V2080 (value shen.*special*)))

(defun shen.extraspecial? (V2081) (element? V2081 (value shen.*extraspecial*)))

(defun shen.t* (V2082 V2083 V2084 V2085) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2084) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2084 (freeze (bind Error (shen.errormaxinfs) V2084 V2085))))) (if (= Case false) (let Case (let V2071 (shen.lazyderef V2082 V2084) (if (= fail V2071) (do (shen.incinfs) (cut Throwcontrol V2084 (freeze (shen.prolog-failure V2084 V2085)))) false)) (if (= Case false) (let Case (let V2072 (shen.lazyderef V2082 V2084) (if (cons? V2072) (let X (hd V2072) (let V2073 (shen.lazyderef (tl V2072) V2084) (if (cons? V2073) (let V2074 (shen.lazyderef (hd V2073) V2084) (if (= : V2074) (let V2075 (shen.lazyderef (tl V2073) V2084) (if (cons? V2075) (let A (hd V2075) (let V2076 (shen.lazyderef (tl V2075) V2084) (if (= () V2076) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2084 (freeze (cut Throwcontrol V2084 (freeze (shen.th* X A V2083 V2084 V2085)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2084) (do (shen.incinfs) (shen.show V2082 V2083 V2084 (freeze (bind Datatypes (value shen.*datatypes*) V2084 (freeze (shen.udefs* V2082 V2083 Datatypes V2084 V2085))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2090) (cond ((= + V2090) (set shen.*shen-type-theory-enabled?* true)) ((= - V2090) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2099 V2100) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2101 V2102 V2103 V2104 V2105) (let Case (let V2067 (shen.lazyderef V2103 V2104) (if (cons? V2067) (let D (hd V2067) (do (shen.incinfs) (call (cons D (cons V2101 (cons V2102 ()))) V2104 V2105))) false)) (if (= Case false) (let V2068 (shen.lazyderef V2103 V2104) (if (cons? V2068) (let Ds (tl V2068) (do (shen.incinfs) (shen.udefs* V2101 V2102 Ds V2104 V2105))) false)) Case)))

(defun shen.th* (V2106 V2107 V2108 V2109 V2110) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2106 (cons : (cons V2107 ()))) V2108 V2109 (freeze (fwhen false V2109 V2110)))) (if (= Case false) (let Case (let F (shen.newpv V2109) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2106 V2109)) V2109 (freeze (bind F (shen.sigf (shen.lazyderef V2106 V2109)) V2109 (freeze (call (cons F (cons V2107 ())) V2109 V2110))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2106 V2107 V2109 V2110)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2106 V2107 V2108 V2109 V2110)) (if (= Case false) (let Case (let V1963 (shen.lazyderef V2106 V2109) (if (cons? V1963) (let F (hd V1963) (let V1964 (shen.lazyderef (tl V1963) V2109) (if (= () V1964) (do (shen.incinfs) (shen.th* F (cons --> (cons V2107 ())) V2108 V2109 V2110)) false))) false)) (if (= Case false) (let Case (let V1965 (shen.lazyderef V2106 V2109) (if (cons? V1965) (let F (hd V1965) (let V1966 (shen.lazyderef (tl V1965) V2109) (if (cons? V1966) (let X (hd V1966) (let V1967 (shen.lazyderef (tl V1966) V2109) (if (= () V1967) (let B (shen.newpv V2109) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2107 ()))) V2108 V2109 (freeze (shen.th* X B V2108 V2109 V2110))))) false))) false))) false)) (if (= Case false) (let Case (let V1968 (shen.lazyderef V2106 V2109) (if (cons? V1968) (let V1969 (shen.lazyderef (hd V1968) V2109) (if (= cons V1969) (let V1970 (shen.lazyderef (tl V1968) V2109) (if (cons? V1970) (let X (hd V1970) (let V1971 (shen.lazyderef (tl V1970) V2109) (if (cons? V1971) (let Y (hd V1971) (let V1972 (shen.lazyderef (tl V1971) V2109) (if (= () V1972) (let V1973 (shen.lazyderef V2107 V2109) (if (cons? V1973) (let V1974 (shen.lazyderef (hd V1973) V2109) (if (= list V1974) (let V1975 (shen.lazyderef (tl V1973) V2109) (if (cons? V1975) (let A (hd V1975) (let V1976 (shen.lazyderef (tl V1975) V2109) (if (= () V1976) (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons list (cons A ())) V2108 V2109 V2110)))) (if (shen.pvar? V1976) (do (shen.bindv V1976 () V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons list (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V1976 V2109) Result))) false)))) (if (shen.pvar? V1975) (let A (shen.newpv V2109) (do (shen.bindv V1975 (cons A ()) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons list (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V1975 V2109) Result)))) false))) (if (shen.pvar? V1974) (do (shen.bindv V1974 list V2109) (let Result (let V1977 (shen.lazyderef (tl V1973) V2109) (if (cons? V1977) (let A (hd V1977) (let V1978 (shen.lazyderef (tl V1977) V2109) (if (= () V1978) (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons list (cons A ())) V2108 V2109 V2110)))) (if (shen.pvar? V1978) (do (shen.bindv V1978 () V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons list (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V1978 V2109) Result))) false)))) (if (shen.pvar? V1977) (let A (shen.newpv V2109) (do (shen.bindv V1977 (cons A ()) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons list (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V1977 V2109) Result)))) false))) (do (shen.unbindv V1974 V2109) Result))) false))) (if (shen.pvar? V1973) (let A (shen.newpv V2109) (do (shen.bindv V1973 (cons list (cons A ())) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons list (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V1973 V2109) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1979 (shen.lazyderef V2106 V2109) (if (cons? V1979) (let V1980 (shen.lazyderef (hd V1979) V2109) (if (= @p V1980) (let V1981 (shen.lazyderef (tl V1979) V2109) (if (cons? V1981) (let X (hd V1981) (let V1982 (shen.lazyderef (tl V1981) V2109) (if (cons? V1982) (let Y (hd V1982) (let V1983 (shen.lazyderef (tl V1982) V2109) (if (= () V1983) (let V1984 (shen.lazyderef V2107 V2109) (if (cons? V1984) (let A (hd V1984) (let V1985 (shen.lazyderef (tl V1984) V2109) (if (cons? V1985) (let V1986 (shen.lazyderef (hd V1985) V2109) (if (= * V1986) (let V1987 (shen.lazyderef (tl V1985) V2109) (if (cons? V1987) (let B (hd V1987) (let V1988 (shen.lazyderef (tl V1987) V2109) (if (= () V1988) (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y B V2108 V2109 V2110)))) (if (shen.pvar? V1988) (do (shen.bindv V1988 () V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y B V2108 V2109 V2110)))) (do (shen.unbindv V1988 V2109) Result))) false)))) (if (shen.pvar? V1987) (let B (shen.newpv V2109) (do (shen.bindv V1987 (cons B ()) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y B V2108 V2109 V2110)))) (do (shen.unbindv V1987 V2109) Result)))) false))) (if (shen.pvar? V1986) (do (shen.bindv V1986 * V2109) (let Result (let V1989 (shen.lazyderef (tl V1985) V2109) (if (cons? V1989) (let B (hd V1989) (let V1990 (shen.lazyderef (tl V1989) V2109) (if (= () V1990) (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y B V2108 V2109 V2110)))) (if (shen.pvar? V1990) (do (shen.bindv V1990 () V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y B V2108 V2109 V2110)))) (do (shen.unbindv V1990 V2109) Result))) false)))) (if (shen.pvar? V1989) (let B (shen.newpv V2109) (do (shen.bindv V1989 (cons B ()) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y B V2108 V2109 V2110)))) (do (shen.unbindv V1989 V2109) Result)))) false))) (do (shen.unbindv V1986 V2109) Result))) false))) (if (shen.pvar? V1985) (let B (shen.newpv V2109) (do (shen.bindv V1985 (cons * (cons B ())) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y B V2108 V2109 V2110)))) (do (shen.unbindv V1985 V2109) Result)))) false)))) (if (shen.pvar? V1984) (let A (shen.newpv V2109) (let B (shen.newpv V2109) (do (shen.bindv V1984 (cons A (cons * (cons B ()))) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y B V2108 V2109 V2110)))) (do (shen.unbindv V1984 V2109) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1991 (shen.lazyderef V2106 V2109) (if (cons? V1991) (let V1992 (shen.lazyderef (hd V1991) V2109) (if (= @v V1992) (let V1993 (shen.lazyderef (tl V1991) V2109) (if (cons? V1993) (let X (hd V1993) (let V1994 (shen.lazyderef (tl V1993) V2109) (if (cons? V1994) (let Y (hd V1994) (let V1995 (shen.lazyderef (tl V1994) V2109) (if (= () V1995) (let V1996 (shen.lazyderef V2107 V2109) (if (cons? V1996) (let V1997 (shen.lazyderef (hd V1996) V2109) (if (= vector V1997) (let V1998 (shen.lazyderef (tl V1996) V2109) (if (cons? V1998) (let A (hd V1998) (let V1999 (shen.lazyderef (tl V1998) V2109) (if (= () V1999) (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons vector (cons A ())) V2108 V2109 V2110)))) (if (shen.pvar? V1999) (do (shen.bindv V1999 () V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons vector (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V1999 V2109) Result))) false)))) (if (shen.pvar? V1998) (let A (shen.newpv V2109) (do (shen.bindv V1998 (cons A ()) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons vector (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V1998 V2109) Result)))) false))) (if (shen.pvar? V1997) (do (shen.bindv V1997 vector V2109) (let Result (let V2000 (shen.lazyderef (tl V1996) V2109) (if (cons? V2000) (let A (hd V2000) (let V2001 (shen.lazyderef (tl V2000) V2109) (if (= () V2001) (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons vector (cons A ())) V2108 V2109 V2110)))) (if (shen.pvar? V2001) (do (shen.bindv V2001 () V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons vector (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V2001 V2109) Result))) false)))) (if (shen.pvar? V2000) (let A (shen.newpv V2109) (do (shen.bindv V2000 (cons A ()) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons vector (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V2000 V2109) Result)))) false))) (do (shen.unbindv V1997 V2109) Result))) false))) (if (shen.pvar? V1996) (let A (shen.newpv V2109) (do (shen.bindv V1996 (cons vector (cons A ())) V2109) (let Result (do (shen.incinfs) (shen.th* X A V2108 V2109 (freeze (shen.th* Y (cons vector (cons A ())) V2108 V2109 V2110)))) (do (shen.unbindv V1996 V2109) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2002 (shen.lazyderef V2106 V2109) (if (cons? V2002) (let V2003 (shen.lazyderef (hd V2002) V2109) (if (= @s V2003) (let V2004 (shen.lazyderef (tl V2002) V2109) (if (cons? V2004) (let X (hd V2004) (let V2005 (shen.lazyderef (tl V2004) V2109) (if (cons? V2005) (let Y (hd V2005) (let V2006 (shen.lazyderef (tl V2005) V2109) (if (= () V2006) (let V2007 (shen.lazyderef V2107 V2109) (if (= string V2007) (do (shen.incinfs) (shen.th* X string V2108 V2109 (freeze (shen.th* Y string V2108 V2109 V2110)))) (if (shen.pvar? V2007) (do (shen.bindv V2007 string V2109) (let Result (do (shen.incinfs) (shen.th* X string V2108 V2109 (freeze (shen.th* Y string V2108 V2109 V2110)))) (do (shen.unbindv V2007 V2109) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2008 (shen.lazyderef V2106 V2109) (if (cons? V2008) (let V2009 (shen.lazyderef (hd V2008) V2109) (if (= lambda V2009) (let V2010 (shen.lazyderef (tl V2008) V2109) (if (cons? V2010) (let X (hd V2010) (let V2011 (shen.lazyderef (tl V2010) V2109) (if (cons? V2011) (let Y (hd V2011) (let V2012 (shen.lazyderef (tl V2011) V2109) (if (= () V2012) (let V2013 (shen.lazyderef V2107 V2109) (if (cons? V2013) (let A (hd V2013) (let V2014 (shen.lazyderef (tl V2013) V2109) (if (cons? V2014) (let V2015 (shen.lazyderef (hd V2014) V2109) (if (= --> V2015) (let V2016 (shen.lazyderef (tl V2014) V2109) (if (cons? V2016) (let B (hd V2016) (let V2017 (shen.lazyderef (tl V2016) V2109) (if (= () V2017) (let Z (shen.newpv V2109) (let X&& (shen.newpv V2109) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (bind X&& (shen.placeholder) V2109 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2109) (shen.lazyderef X V2109) (shen.lazyderef Y V2109)) V2109 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2108) V2109 V2110)))))))))) (if (shen.pvar? V2017) (do (shen.bindv V2017 () V2109) (let Result (let Z (shen.newpv V2109) (let X&& (shen.newpv V2109) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (bind X&& (shen.placeholder) V2109 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2109) (shen.lazyderef X V2109) (shen.lazyderef Y V2109)) V2109 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2108) V2109 V2110)))))))))) (do (shen.unbindv V2017 V2109) Result))) false)))) (if (shen.pvar? V2016) (let B (shen.newpv V2109) (do (shen.bindv V2016 (cons B ()) V2109) (let Result (let Z (shen.newpv V2109) (let X&& (shen.newpv V2109) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (bind X&& (shen.placeholder) V2109 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2109) (shen.lazyderef X V2109) (shen.lazyderef Y V2109)) V2109 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2108) V2109 V2110)))))))))) (do (shen.unbindv V2016 V2109) Result)))) false))) (if (shen.pvar? V2015) (do (shen.bindv V2015 --> V2109) (let Result (let V2018 (shen.lazyderef (tl V2014) V2109) (if (cons? V2018) (let B (hd V2018) (let V2019 (shen.lazyderef (tl V2018) V2109) (if (= () V2019) (let Z (shen.newpv V2109) (let X&& (shen.newpv V2109) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (bind X&& (shen.placeholder) V2109 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2109) (shen.lazyderef X V2109) (shen.lazyderef Y V2109)) V2109 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2108) V2109 V2110)))))))))) (if (shen.pvar? V2019) (do (shen.bindv V2019 () V2109) (let Result (let Z (shen.newpv V2109) (let X&& (shen.newpv V2109) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (bind X&& (shen.placeholder) V2109 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2109) (shen.lazyderef X V2109) (shen.lazyderef Y V2109)) V2109 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2108) V2109 V2110)))))))))) (do (shen.unbindv V2019 V2109) Result))) false)))) (if (shen.pvar? V2018) (let B (shen.newpv V2109) (do (shen.bindv V2018 (cons B ()) V2109) (let Result (let Z (shen.newpv V2109) (let X&& (shen.newpv V2109) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (bind X&& (shen.placeholder) V2109 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2109) (shen.lazyderef X V2109) (shen.lazyderef Y V2109)) V2109 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2108) V2109 V2110)))))))))) (do (shen.unbindv V2018 V2109) Result)))) false))) (do (shen.unbindv V2015 V2109) Result))) false))) (if (shen.pvar? V2014) (let B (shen.newpv V2109) (do (shen.bindv V2014 (cons --> (cons B ())) V2109) (let Result (let Z (shen.newpv V2109) (let X&& (shen.newpv V2109) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (bind X&& (shen.placeholder) V2109 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2109) (shen.lazyderef X V2109) (shen.lazyderef Y V2109)) V2109 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2108) V2109 V2110)))))))))) (do (shen.unbindv V2014 V2109) Result)))) false)))) (if (shen.pvar? V2013) (let A (shen.newpv V2109) (let B (shen.newpv V2109) (do (shen.bindv V2013 (cons A (cons --> (cons B ()))) V2109) (let Result (let Z (shen.newpv V2109) (let X&& (shen.newpv V2109) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (bind X&& (shen.placeholder) V2109 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2109) (shen.lazyderef X V2109) (shen.lazyderef Y V2109)) V2109 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2108) V2109 V2110)))))))))) (do (shen.unbindv V2013 V2109) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2020 (shen.lazyderef V2106 V2109) (if (cons? V2020) (let V2021 (shen.lazyderef (hd V2020) V2109) (if (= let V2021) (let V2022 (shen.lazyderef (tl V2020) V2109) (if (cons? V2022) (let X (hd V2022) (let V2023 (shen.lazyderef (tl V2022) V2109) (if (cons? V2023) (let Y (hd V2023) (let V2024 (shen.lazyderef (tl V2023) V2109) (if (cons? V2024) (let Z (hd V2024) (let V2025 (shen.lazyderef (tl V2024) V2109) (if (= () V2025) (let W (shen.newpv V2109) (let X&& (shen.newpv V2109) (let B (shen.newpv V2109) (do (shen.incinfs) (shen.th* Y B V2108 V2109 (freeze (bind X&& (shen.placeholder) V2109 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2109) (shen.lazyderef X V2109) (shen.lazyderef Z V2109)) V2109 (freeze (shen.th* W V2107 (cons (cons X&& (cons : (cons B ()))) V2108) V2109 V2110))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2026 (shen.lazyderef V2106 V2109) (if (cons? V2026) (let V2027 (shen.lazyderef (hd V2026) V2109) (if (= open V2027) (let V2028 (shen.lazyderef (tl V2026) V2109) (if (cons? V2028) (let FileName (hd V2028) (let V2029 (shen.lazyderef (tl V2028) V2109) (if (cons? V2029) (let Direction1959 (hd V2029) (let V2030 (shen.lazyderef (tl V2029) V2109) (if (= () V2030) (let V2031 (shen.lazyderef V2107 V2109) (if (cons? V2031) (let V2032 (shen.lazyderef (hd V2031) V2109) (if (= stream V2032) (let V2033 (shen.lazyderef (tl V2031) V2109) (if (cons? V2033) (let Direction (hd V2033) (let V2034 (shen.lazyderef (tl V2033) V2109) (if (= () V2034) (do (shen.incinfs) (unify! Direction Direction1959 V2109 (freeze (cut Throwcontrol V2109 (freeze (shen.th* FileName string V2108 V2109 V2110)))))) (if (shen.pvar? V2034) (do (shen.bindv V2034 () V2109) (let Result (do (shen.incinfs) (unify! Direction Direction1959 V2109 (freeze (cut Throwcontrol V2109 (freeze (shen.th* FileName string V2108 V2109 V2110)))))) (do (shen.unbindv V2034 V2109) Result))) false)))) (if (shen.pvar? V2033) (let Direction (shen.newpv V2109) (do (shen.bindv V2033 (cons Direction ()) V2109) (let Result (do (shen.incinfs) (unify! Direction Direction1959 V2109 (freeze (cut Throwcontrol V2109 (freeze (shen.th* FileName string V2108 V2109 V2110)))))) (do (shen.unbindv V2033 V2109) Result)))) false))) (if (shen.pvar? V2032) (do (shen.bindv V2032 stream V2109) (let Result (let V2035 (shen.lazyderef (tl V2031) V2109) (if (cons? V2035) (let Direction (hd V2035) (let V2036 (shen.lazyderef (tl V2035) V2109) (if (= () V2036) (do (shen.incinfs) (unify! Direction Direction1959 V2109 (freeze (cut Throwcontrol V2109 (freeze (shen.th* FileName string V2108 V2109 V2110)))))) (if (shen.pvar? V2036) (do (shen.bindv V2036 () V2109) (let Result (do (shen.incinfs) (unify! Direction Direction1959 V2109 (freeze (cut Throwcontrol V2109 (freeze (shen.th* FileName string V2108 V2109 V2110)))))) (do (shen.unbindv V2036 V2109) Result))) false)))) (if (shen.pvar? V2035) (let Direction (shen.newpv V2109) (do (shen.bindv V2035 (cons Direction ()) V2109) (let Result (do (shen.incinfs) (unify! Direction Direction1959 V2109 (freeze (cut Throwcontrol V2109 (freeze (shen.th* FileName string V2108 V2109 V2110)))))) (do (shen.unbindv V2035 V2109) Result)))) false))) (do (shen.unbindv V2032 V2109) Result))) false))) (if (shen.pvar? V2031) (let Direction (shen.newpv V2109) (do (shen.bindv V2031 (cons stream (cons Direction ())) V2109) (let Result (do (shen.incinfs) (unify! Direction Direction1959 V2109 (freeze (cut Throwcontrol V2109 (freeze (shen.th* FileName string V2108 V2109 V2110)))))) (do (shen.unbindv V2031 V2109) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2037 (shen.lazyderef V2106 V2109) (if (cons? V2037) (let V2038 (shen.lazyderef (hd V2037) V2109) (if (= type V2038) (let V2039 (shen.lazyderef (tl V2037) V2109) (if (cons? V2039) (let X (hd V2039) (let V2040 (shen.lazyderef (tl V2039) V2109) (if (cons? V2040) (let A (hd V2040) (let V2041 (shen.lazyderef (tl V2040) V2109) (if (= () V2041) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (unify A V2107 V2109 (freeze (shen.th* X A V2108 V2109 V2110)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2042 (shen.lazyderef V2106 V2109) (if (cons? V2042) (let V2043 (shen.lazyderef (hd V2042) V2109) (if (= input+ V2043) (let V2044 (shen.lazyderef (tl V2042) V2109) (if (cons? V2044) (let A (hd V2044) (let V2045 (shen.lazyderef (tl V2044) V2109) (if (cons? V2045) (let Stream (hd V2045) (let V2046 (shen.lazyderef (tl V2045) V2109) (if (= () V2046) (let C (shen.newpv V2109) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2109)) V2109 (freeze (unify V2107 C V2109 (freeze (shen.th* Stream (cons stream (cons in ())) V2108 V2109 V2110))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2047 (shen.lazyderef V2106 V2109) (if (cons? V2047) (let V2048 (shen.lazyderef (hd V2047) V2109) (if (= set V2048) (let V2049 (shen.lazyderef (tl V2047) V2109) (if (cons? V2049) (let Var (hd V2049) (let V2050 (shen.lazyderef (tl V2049) V2109) (if (cons? V2050) (let Val (hd V2050) (let V2051 (shen.lazyderef (tl V2050) V2109) (if (= () V2051) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (shen.th* Var symbol V2108 V2109 (freeze (cut Throwcontrol V2109 (freeze (shen.th* (cons value (cons Var ())) V2107 V2108 V2109 (freeze (shen.th* Val V2107 V2108 V2109 V2110)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2109) (do (shen.incinfs) (shen.t*-hyps V2108 NewHyp V2109 (freeze (shen.th* V2106 V2107 NewHyp V2109 V2110))))) (if (= Case false) (let Case (let V2052 (shen.lazyderef V2106 V2109) (if (cons? V2052) (let V2053 (shen.lazyderef (hd V2052) V2109) (if (= define V2053) (let V2054 (shen.lazyderef (tl V2052) V2109) (if (cons? V2054) (let F (hd V2054) (let X (tl V2054) (do (shen.incinfs) (cut Throwcontrol V2109 (freeze (shen.t*-def (cons define (cons F X)) V2107 V2108 V2109 V2110)))))) false)) false)) false)) (if (= Case false) (let Case (let V2055 (shen.lazyderef V2106 V2109) (if (cons? V2055) (let V2056 (shen.lazyderef (hd V2055) V2109) (if (= defmacro V2056) (let V2057 (shen.lazyderef V2107 V2109) (if (= unit V2057) (do (shen.incinfs) (cut Throwcontrol V2109 V2110)) (if (shen.pvar? V2057) (do (shen.bindv V2057 unit V2109) (let Result (do (shen.incinfs) (cut Throwcontrol V2109 V2110)) (do (shen.unbindv V2057 V2109) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2058 (shen.lazyderef V2106 V2109) (if (cons? V2058) (let V2059 (shen.lazyderef (hd V2058) V2109) (if (= shen.process-datatype V2059) (let V2060 (shen.lazyderef V2107 V2109) (if (= symbol V2060) (do (shen.incinfs) (thaw V2110)) (if (shen.pvar? V2060) (do (shen.bindv V2060 symbol V2109) (let Result (do (shen.incinfs) (thaw V2110)) (do (shen.unbindv V2060 V2109) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2061 (shen.lazyderef V2106 V2109) (if (cons? V2061) (let V2062 (shen.lazyderef (hd V2061) V2109) (if (= shen.synonyms-help V2062) (let V2063 (shen.lazyderef V2107 V2109) (if (= symbol V2063) (do (shen.incinfs) (thaw V2110)) (if (shen.pvar? V2063) (do (shen.bindv V2063 symbol V2109) (let Result (do (shen.incinfs) (thaw V2110)) (do (shen.unbindv V2063 V2109) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2109) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2109 (freeze (shen.udefs* (cons V2106 (cons : (cons V2107 ()))) V2108 Datatypes V2109 V2110))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2111 V2112 V2113 V2114) (let Case (let V1874 (shen.lazyderef V2111 V2113) (if (cons? V1874) (let V1875 (shen.lazyderef (hd V1874) V2113) (if (cons? V1875) (let V1876 (shen.lazyderef (hd V1875) V2113) (if (cons? V1876) (let V1877 (shen.lazyderef (hd V1876) V2113) (if (= cons V1877) (let V1878 (shen.lazyderef (tl V1876) V2113) (if (cons? V1878) (let X (hd V1878) (let V1879 (shen.lazyderef (tl V1878) V2113) (if (cons? V1879) (let Y (hd V1879) (let V1880 (shen.lazyderef (tl V1879) V2113) (if (= () V1880) (let V1881 (shen.lazyderef (tl V1875) V2113) (if (cons? V1881) (let V1882 (shen.lazyderef (hd V1881) V2113) (if (= : V1882) (let V1883 (shen.lazyderef (tl V1881) V2113) (if (cons? V1883) (let V1884 (shen.lazyderef (hd V1883) V2113) (if (cons? V1884) (let V1885 (shen.lazyderef (hd V1884) V2113) (if (= list V1885) (let V1886 (shen.lazyderef (tl V1884) V2113) (if (cons? V1886) (let A (hd V1886) (let V1887 (shen.lazyderef (tl V1886) V2113) (if (= () V1887) (let V1888 (shen.lazyderef (tl V1883) V2113) (if (= () V1888) (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1888) (do (shen.bindv V1888 () V2113) (let Result (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1888 V2113) Result))) false))) (if (shen.pvar? V1887) (do (shen.bindv V1887 () V2113) (let Result (let V1889 (shen.lazyderef (tl V1883) V2113) (if (= () V1889) (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1889) (do (shen.bindv V1889 () V2113) (let Result (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1889 V2113) Result))) false))) (do (shen.unbindv V1887 V2113) Result))) false)))) (if (shen.pvar? V1886) (let A (shen.newpv V2113) (do (shen.bindv V1886 (cons A ()) V2113) (let Result (let V1890 (shen.lazyderef (tl V1883) V2113) (if (= () V1890) (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1890) (do (shen.bindv V1890 () V2113) (let Result (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1890 V2113) Result))) false))) (do (shen.unbindv V1886 V2113) Result)))) false))) (if (shen.pvar? V1885) (do (shen.bindv V1885 list V2113) (let Result (let V1891 (shen.lazyderef (tl V1884) V2113) (if (cons? V1891) (let A (hd V1891) (let V1892 (shen.lazyderef (tl V1891) V2113) (if (= () V1892) (let V1893 (shen.lazyderef (tl V1883) V2113) (if (= () V1893) (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1893) (do (shen.bindv V1893 () V2113) (let Result (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1893 V2113) Result))) false))) (if (shen.pvar? V1892) (do (shen.bindv V1892 () V2113) (let Result (let V1894 (shen.lazyderef (tl V1883) V2113) (if (= () V1894) (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1894) (do (shen.bindv V1894 () V2113) (let Result (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1894 V2113) Result))) false))) (do (shen.unbindv V1892 V2113) Result))) false)))) (if (shen.pvar? V1891) (let A (shen.newpv V2113) (do (shen.bindv V1891 (cons A ()) V2113) (let Result (let V1895 (shen.lazyderef (tl V1883) V2113) (if (= () V1895) (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1895) (do (shen.bindv V1895 () V2113) (let Result (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1895 V2113) Result))) false))) (do (shen.unbindv V1891 V2113) Result)))) false))) (do (shen.unbindv V1885 V2113) Result))) false))) (if (shen.pvar? V1884) (let A (shen.newpv V2113) (do (shen.bindv V1884 (cons list (cons A ())) V2113) (let Result (let V1896 (shen.lazyderef (tl V1883) V2113) (if (= () V1896) (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1896) (do (shen.bindv V1896 () V2113) (let Result (let Hyp (tl V1874) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons list (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1896 V2113) Result))) false))) (do (shen.unbindv V1884 V2113) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1897 (shen.lazyderef V2111 V2113) (if (cons? V1897) (let V1898 (shen.lazyderef (hd V1897) V2113) (if (cons? V1898) (let V1899 (shen.lazyderef (hd V1898) V2113) (if (cons? V1899) (let V1900 (shen.lazyderef (hd V1899) V2113) (if (= @p V1900) (let V1901 (shen.lazyderef (tl V1899) V2113) (if (cons? V1901) (let X (hd V1901) (let V1902 (shen.lazyderef (tl V1901) V2113) (if (cons? V1902) (let Y (hd V1902) (let V1903 (shen.lazyderef (tl V1902) V2113) (if (= () V1903) (let V1904 (shen.lazyderef (tl V1898) V2113) (if (cons? V1904) (let V1905 (shen.lazyderef (hd V1904) V2113) (if (= : V1905) (let V1906 (shen.lazyderef (tl V1904) V2113) (if (cons? V1906) (let V1907 (shen.lazyderef (hd V1906) V2113) (if (cons? V1907) (let A (hd V1907) (let V1908 (shen.lazyderef (tl V1907) V2113) (if (cons? V1908) (let V1909 (shen.lazyderef (hd V1908) V2113) (if (= * V1909) (let V1910 (shen.lazyderef (tl V1908) V2113) (if (cons? V1910) (let B (hd V1910) (let V1911 (shen.lazyderef (tl V1910) V2113) (if (= () V1911) (let V1912 (shen.lazyderef (tl V1906) V2113) (if (= () V1912) (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1912) (do (shen.bindv V1912 () V2113) (let Result (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1912 V2113) Result))) false))) (if (shen.pvar? V1911) (do (shen.bindv V1911 () V2113) (let Result (let V1913 (shen.lazyderef (tl V1906) V2113) (if (= () V1913) (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1913) (do (shen.bindv V1913 () V2113) (let Result (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1913 V2113) Result))) false))) (do (shen.unbindv V1911 V2113) Result))) false)))) (if (shen.pvar? V1910) (let B (shen.newpv V2113) (do (shen.bindv V1910 (cons B ()) V2113) (let Result (let V1914 (shen.lazyderef (tl V1906) V2113) (if (= () V1914) (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1914) (do (shen.bindv V1914 () V2113) (let Result (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1914 V2113) Result))) false))) (do (shen.unbindv V1910 V2113) Result)))) false))) (if (shen.pvar? V1909) (do (shen.bindv V1909 * V2113) (let Result (let V1915 (shen.lazyderef (tl V1908) V2113) (if (cons? V1915) (let B (hd V1915) (let V1916 (shen.lazyderef (tl V1915) V2113) (if (= () V1916) (let V1917 (shen.lazyderef (tl V1906) V2113) (if (= () V1917) (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1917) (do (shen.bindv V1917 () V2113) (let Result (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1917 V2113) Result))) false))) (if (shen.pvar? V1916) (do (shen.bindv V1916 () V2113) (let Result (let V1918 (shen.lazyderef (tl V1906) V2113) (if (= () V1918) (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1918) (do (shen.bindv V1918 () V2113) (let Result (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1918 V2113) Result))) false))) (do (shen.unbindv V1916 V2113) Result))) false)))) (if (shen.pvar? V1915) (let B (shen.newpv V2113) (do (shen.bindv V1915 (cons B ()) V2113) (let Result (let V1919 (shen.lazyderef (tl V1906) V2113) (if (= () V1919) (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1919) (do (shen.bindv V1919 () V2113) (let Result (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1919 V2113) Result))) false))) (do (shen.unbindv V1915 V2113) Result)))) false))) (do (shen.unbindv V1909 V2113) Result))) false))) (if (shen.pvar? V1908) (let B (shen.newpv V2113) (do (shen.bindv V1908 (cons * (cons B ())) V2113) (let Result (let V1920 (shen.lazyderef (tl V1906) V2113) (if (= () V1920) (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1920) (do (shen.bindv V1920 () V2113) (let Result (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1920 V2113) Result))) false))) (do (shen.unbindv V1908 V2113) Result)))) false)))) (if (shen.pvar? V1907) (let A (shen.newpv V2113) (let B (shen.newpv V2113) (do (shen.bindv V1907 (cons A (cons * (cons B ()))) V2113) (let Result (let V1921 (shen.lazyderef (tl V1906) V2113) (if (= () V1921) (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1921) (do (shen.bindv V1921 () V2113) (let Result (let Hyp (tl V1897) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (shen.lazyderef B V2113) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1921 V2113) Result))) false))) (do (shen.unbindv V1907 V2113) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1922 (shen.lazyderef V2111 V2113) (if (cons? V1922) (let V1923 (shen.lazyderef (hd V1922) V2113) (if (cons? V1923) (let V1924 (shen.lazyderef (hd V1923) V2113) (if (cons? V1924) (let V1925 (shen.lazyderef (hd V1924) V2113) (if (= @v V1925) (let V1926 (shen.lazyderef (tl V1924) V2113) (if (cons? V1926) (let X (hd V1926) (let V1927 (shen.lazyderef (tl V1926) V2113) (if (cons? V1927) (let Y (hd V1927) (let V1928 (shen.lazyderef (tl V1927) V2113) (if (= () V1928) (let V1929 (shen.lazyderef (tl V1923) V2113) (if (cons? V1929) (let V1930 (shen.lazyderef (hd V1929) V2113) (if (= : V1930) (let V1931 (shen.lazyderef (tl V1929) V2113) (if (cons? V1931) (let V1932 (shen.lazyderef (hd V1931) V2113) (if (cons? V1932) (let V1933 (shen.lazyderef (hd V1932) V2113) (if (= vector V1933) (let V1934 (shen.lazyderef (tl V1932) V2113) (if (cons? V1934) (let A (hd V1934) (let V1935 (shen.lazyderef (tl V1934) V2113) (if (= () V1935) (let V1936 (shen.lazyderef (tl V1931) V2113) (if (= () V1936) (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1936) (do (shen.bindv V1936 () V2113) (let Result (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1936 V2113) Result))) false))) (if (shen.pvar? V1935) (do (shen.bindv V1935 () V2113) (let Result (let V1937 (shen.lazyderef (tl V1931) V2113) (if (= () V1937) (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1937) (do (shen.bindv V1937 () V2113) (let Result (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1937 V2113) Result))) false))) (do (shen.unbindv V1935 V2113) Result))) false)))) (if (shen.pvar? V1934) (let A (shen.newpv V2113) (do (shen.bindv V1934 (cons A ()) V2113) (let Result (let V1938 (shen.lazyderef (tl V1931) V2113) (if (= () V1938) (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1938) (do (shen.bindv V1938 () V2113) (let Result (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1938 V2113) Result))) false))) (do (shen.unbindv V1934 V2113) Result)))) false))) (if (shen.pvar? V1933) (do (shen.bindv V1933 vector V2113) (let Result (let V1939 (shen.lazyderef (tl V1932) V2113) (if (cons? V1939) (let A (hd V1939) (let V1940 (shen.lazyderef (tl V1939) V2113) (if (= () V1940) (let V1941 (shen.lazyderef (tl V1931) V2113) (if (= () V1941) (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1941) (do (shen.bindv V1941 () V2113) (let Result (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1941 V2113) Result))) false))) (if (shen.pvar? V1940) (do (shen.bindv V1940 () V2113) (let Result (let V1942 (shen.lazyderef (tl V1931) V2113) (if (= () V1942) (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1942) (do (shen.bindv V1942 () V2113) (let Result (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1942 V2113) Result))) false))) (do (shen.unbindv V1940 V2113) Result))) false)))) (if (shen.pvar? V1939) (let A (shen.newpv V2113) (do (shen.bindv V1939 (cons A ()) V2113) (let Result (let V1943 (shen.lazyderef (tl V1931) V2113) (if (= () V1943) (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1943) (do (shen.bindv V1943 () V2113) (let Result (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1943 V2113) Result))) false))) (do (shen.unbindv V1939 V2113) Result)))) false))) (do (shen.unbindv V1933 V2113) Result))) false))) (if (shen.pvar? V1932) (let A (shen.newpv V2113) (do (shen.bindv V1932 (cons vector (cons A ())) V2113) (let Result (let V1944 (shen.lazyderef (tl V1931) V2113) (if (= () V1944) (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1944) (do (shen.bindv V1944 () V2113) (let Result (let Hyp (tl V1922) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons (shen.lazyderef A V2113) ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons (cons vector (cons (shen.lazyderef A V2113) ())) ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1944 V2113) Result))) false))) (do (shen.unbindv V1932 V2113) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1945 (shen.lazyderef V2111 V2113) (if (cons? V1945) (let V1946 (shen.lazyderef (hd V1945) V2113) (if (cons? V1946) (let V1947 (shen.lazyderef (hd V1946) V2113) (if (cons? V1947) (let V1948 (shen.lazyderef (hd V1947) V2113) (if (= @s V1948) (let V1949 (shen.lazyderef (tl V1947) V2113) (if (cons? V1949) (let X (hd V1949) (let V1950 (shen.lazyderef (tl V1949) V2113) (if (cons? V1950) (let Y (hd V1950) (let V1951 (shen.lazyderef (tl V1950) V2113) (if (= () V1951) (let V1952 (shen.lazyderef (tl V1946) V2113) (if (cons? V1952) (let V1953 (shen.lazyderef (hd V1952) V2113) (if (= : V1953) (let V1954 (shen.lazyderef (tl V1952) V2113) (if (cons? V1954) (let V1955 (shen.lazyderef (hd V1954) V2113) (if (= string V1955) (let V1956 (shen.lazyderef (tl V1954) V2113) (if (= () V1956) (let Hyp (tl V1945) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons string ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1956) (do (shen.bindv V1956 () V2113) (let Result (let Hyp (tl V1945) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons string ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1956 V2113) Result))) false))) (if (shen.pvar? V1955) (do (shen.bindv V1955 string V2113) (let Result (let V1957 (shen.lazyderef (tl V1954) V2113) (if (= () V1957) (let Hyp (tl V1945) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons string ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (if (shen.pvar? V1957) (do (shen.bindv V1957 () V2113) (let Result (let Hyp (tl V1945) (do (shen.incinfs) (bind V2112 (cons (cons (shen.lazyderef X V2113) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2113) (cons : (cons string ()))) (shen.lazyderef Hyp V2113))) V2113 V2114))) (do (shen.unbindv V1957 V2113) Result))) false))) (do (shen.unbindv V1955 V2113) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V1958 (shen.lazyderef V2111 V2113) (if (cons? V1958) (let X (hd V1958) (let Hyp (tl V1958) (let NewHyps (shen.newpv V2113) (do (shen.incinfs) (bind V2112 (cons (shen.lazyderef X V2113) (shen.lazyderef NewHyps V2113)) V2113 (freeze (shen.t*-hyps Hyp NewHyps V2113 V2114))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2127 V2128 V2129 V2130) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2127 V2129)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2128 V2129) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2130))))))))) (true (thaw V2130))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2131) (cond ((and (cons? V2131) (and (cons? (tl V2131)) (and (= : (hd (tl V2131))) (and (cons? (tl (tl V2131))) (= () (tl (tl (tl V2131)))))))) (shen.prhush (shen.app (hd V2131) (cn " : " (shen.app (hd (tl (tl V2131))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2131 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2134 V2135) (cond ((= () V2134) shen.skip) ((cons? V2134) (do (shen.prhush (shen.app V2135 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2134)) (do (nl 1) (shen.show-assumptions (tl V2134) (+ V2135 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2136) (cons? (assoc V2136 (value shen.*signedfuncs*))))

(defun shen.sigf (V2137) (concat shen.type-signature-of- V2137))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2138 V2139 V2140 V2141) (let Case (let V1861 (shen.lazyderef V2139 V2140) (if (= number V1861) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2138 V2140)) V2140 V2141)) (if (shen.pvar? V1861) (do (shen.bindv V1861 number V2140) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2138 V2140)) V2140 V2141)) (do (shen.unbindv V1861 V2140) Result))) false))) (if (= Case false) (let Case (let V1862 (shen.lazyderef V2139 V2140) (if (= boolean V1862) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2138 V2140)) V2140 V2141)) (if (shen.pvar? V1862) (do (shen.bindv V1862 boolean V2140) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2138 V2140)) V2140 V2141)) (do (shen.unbindv V1862 V2140) Result))) false))) (if (= Case false) (let Case (let V1863 (shen.lazyderef V2139 V2140) (if (= string V1863) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2138 V2140)) V2140 V2141)) (if (shen.pvar? V1863) (do (shen.bindv V1863 string V2140) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2138 V2140)) V2140 V2141)) (do (shen.unbindv V1863 V2140) Result))) false))) (if (= Case false) (let Case (let V1864 (shen.lazyderef V2139 V2140) (if (= symbol V1864) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2138 V2140)) V2140 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2138 V2140))) V2140 V2141)))) (if (shen.pvar? V1864) (do (shen.bindv V1864 symbol V2140) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2138 V2140)) V2140 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2138 V2140))) V2140 V2141)))) (do (shen.unbindv V1864 V2140) Result))) false))) (if (= Case false) (let V1865 (shen.lazyderef V2138 V2140) (if (= () V1865) (let V1866 (shen.lazyderef V2139 V2140) (if (cons? V1866) (let V1867 (shen.lazyderef (hd V1866) V2140) (if (= list V1867) (let V1868 (shen.lazyderef (tl V1866) V2140) (if (cons? V1868) (let A (hd V1868) (let V1869 (shen.lazyderef (tl V1868) V2140) (if (= () V1869) (do (shen.incinfs) (thaw V2141)) (if (shen.pvar? V1869) (do (shen.bindv V1869 () V2140) (let Result (do (shen.incinfs) (thaw V2141)) (do (shen.unbindv V1869 V2140) Result))) false)))) (if (shen.pvar? V1868) (let A (shen.newpv V2140) (do (shen.bindv V1868 (cons A ()) V2140) (let Result (do (shen.incinfs) (thaw V2141)) (do (shen.unbindv V1868 V2140) Result)))) false))) (if (shen.pvar? V1867) (do (shen.bindv V1867 list V2140) (let Result (let V1870 (shen.lazyderef (tl V1866) V2140) (if (cons? V1870) (let A (hd V1870) (let V1871 (shen.lazyderef (tl V1870) V2140) (if (= () V1871) (do (shen.incinfs) (thaw V2141)) (if (shen.pvar? V1871) (do (shen.bindv V1871 () V2140) (let Result (do (shen.incinfs) (thaw V2141)) (do (shen.unbindv V1871 V2140) Result))) false)))) (if (shen.pvar? V1870) (let A (shen.newpv V2140) (do (shen.bindv V1870 (cons A ()) V2140) (let Result (do (shen.incinfs) (thaw V2141)) (do (shen.unbindv V1870 V2140) Result)))) false))) (do (shen.unbindv V1867 V2140) Result))) false))) (if (shen.pvar? V1866) (let A (shen.newpv V2140) (do (shen.bindv V1866 (cons list (cons A ())) V2140) (let Result (do (shen.incinfs) (thaw V2141)) (do (shen.unbindv V1866 V2140) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2142 V2143 V2144 V2145 V2146) (let Case (let V1852 (shen.lazyderef V2144 V2145) (if (cons? V1852) (let V1853 (shen.lazyderef (hd V1852) V2145) (if (cons? V1853) (let Y (hd V1853) (let V1854 (shen.lazyderef (tl V1853) V2145) (if (cons? V1854) (let V1855 (shen.lazyderef (hd V1854) V2145) (if (= : V1855) (let V1856 (shen.lazyderef (tl V1854) V2145) (if (cons? V1856) (let B (hd V1856) (let V1857 (shen.lazyderef (tl V1856) V2145) (if (= () V1857) (do (shen.incinfs) (identical V2142 Y V2145 (freeze (unify! V2143 B V2145 V2146)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V1858 (shen.lazyderef V2144 V2145) (if (cons? V1858) (let Hyp (tl V1858) (do (shen.incinfs) (shen.by_hypothesis V2142 V2143 Hyp V2145 V2146))) false)) Case)))

(defun shen.t*-def (V2147 V2148 V2149 V2150 V2151) (let V1846 (shen.lazyderef V2147 V2150) (if (cons? V1846) (let V1847 (shen.lazyderef (hd V1846) V2150) (if (= define V1847) (let V1848 (shen.lazyderef (tl V1846) V2150) (if (cons? V1848) (let F (hd V1848) (let X (tl V1848) (let V1755 (shen.newpv V2150) (let E (shen.newpv V2150) (do (shen.incinfs) (shen.t*-defh (compile (lambda V1755 (shen.<sig+rules> V1755)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2148 V2149 V2150 V2151)))))) false)) false)) false)))

(defun shen.t*-defh (V2152 V2153 V2154 V2155 V2156 V2157) (let V1842 (shen.lazyderef V2152 V2156) (if (cons? V1842) (let Sig (hd V1842) (let Rules (tl V1842) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2153 V2154 V2155 Rules V2156 V2157)))) false)))

(defun shen.t*-defhh (V2158 V2159 V2160 V2161 V2162 V2163 V2164 V2165) (do (shen.incinfs) (shen.t*-rules V2163 V2159 1 V2160 (cons (cons V2160 (cons : (cons V2159 ()))) V2162) V2164 (freeze (shen.memo V2160 V2158 V2161 V2164 V2165)))))

(defun shen.memo (V2166 V2167 V2168 V2169 V2170) (let Jnk (shen.newpv V2169) (do (shen.incinfs) (unify! V2168 V2167 V2169 (freeze (bind Jnk (declare (shen.lazyderef V2166 V2169) (shen.lazyderef V2168 V2169)) V2169 V2170))))))

(defun shen.<sig+rules> (V2171) (let Parse_shen.<signature> (shen.<signature> V2171) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V2172) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V2172) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V2172) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V2173) (cond ((and (cons? V2173) (and (cons? (tl V2173)) (and (= () (tl (tl V2173))) (= (hd V2173) protect)))) V2173) ((cons? V2173) (map (lambda V1756 (shen.ue V1756)) V2173)) ((variable? V2173) (concat && V2173)) (true V2173)))

(defun shen.ue-sig (V2174) (cond ((cons? V2174) (map (lambda V1757 (shen.ue-sig V1757)) V2174)) ((variable? V2174) (concat &&& V2174)) (true V2174)))

(defun shen.ues (V2179) (cond ((shen.ue? V2179) (cons V2179 ())) ((cons? V2179) (union (shen.ues (hd V2179)) (shen.ues (tl V2179)))) (true ())))

(defun shen.ue? (V2180) (and (symbol? V2180) (shen.ue-h? (str V2180))))

(defun shen.ue-h? (V2187) (cond ((and (shen.+string? V2187) (and (= "&" (pos V2187 0)) (and (shen.+string? (tlstr V2187)) (= "&" (pos (tlstr V2187) 0))))) true) (true false)))

(defun shen.t*-rules (V2188 V2189 V2190 V2191 V2192 V2193 V2194) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1826 (shen.lazyderef V2188 V2193) (if (= () V1826) (do (shen.incinfs) (thaw V2194)) false)) (if (= Case false) (let Case (let V1827 (shen.lazyderef V2188 V2193) (if (cons? V1827) (let Rule (hd V1827) (let Rules (tl V1827) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2189 V2192 V2193 (freeze (cut Throwcontrol V2193 (freeze (shen.t*-rules Rules V2189 (+ V2190 1) V2191 V2192 V2193 V2194)))))))) false)) (if (= Case false) (let Err (shen.newpv V2193) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2190 V2193) (cn " of " (shen.app (shen.lazyderef V2191 V2193) "" shen.a)) shen.a))) V2193 V2194))) Case)) Case)))))

(defun shen.t*-rule (V2195 V2196 V2197 V2198 V2199) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V1818 (shen.lazyderef V2195 V2198) (if (cons? V1818) (let Patterns (hd V1818) (let V1819 (shen.lazyderef (tl V1818) V2198) (if (cons? V1819) (let Action (hd V1819) (let V1820 (shen.lazyderef (tl V1819) V2198) (if (= () V1820) (let NewHyps (shen.newpv V2198) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V2197 NewHyps V2198 (freeze (shen.t*-patterns Patterns V2196 NewHyps V2198 (freeze (cut Throwcontrol V2198 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V2196) (shen.patthyps Patterns V2196 V2197) V2198 V2199))))))))) false))) false))) false)))))

(defun shen.placeholders (V2204) (cond ((shen.ue? V2204) (cons V2204 ())) ((cons? V2204) (union (shen.placeholders (hd V2204)) (shen.placeholders (tl V2204)))) (true ())))

(defun shen.newhyps (V2205 V2206 V2207 V2208 V2209) (let Case (let V1805 (shen.lazyderef V2205 V2208) (if (= () V1805) (do (shen.incinfs) (unify! V2207 V2206 V2208 V2209)) false)) (if (= Case false) (let V1806 (shen.lazyderef V2205 V2208) (if (cons? V1806) (let V1801 (hd V1806) (let Vs (tl V1806) (let V1807 (shen.lazyderef V2207 V2208) (if (cons? V1807) (let V1808 (shen.lazyderef (hd V1807) V2208) (if (cons? V1808) (let V (hd V1808) (let V1809 (shen.lazyderef (tl V1808) V2208) (if (cons? V1809) (let V1810 (shen.lazyderef (hd V1809) V2208) (if (= : V1810) (let V1811 (shen.lazyderef (tl V1809) V2208) (if (cons? V1811) (let A (hd V1811) (let V1812 (shen.lazyderef (tl V1811) V2208) (if (= () V1812) (let NewHyp (tl V1807) (do (shen.incinfs) (unify! V V1801 V2208 (freeze (shen.newhyps Vs V2206 NewHyp V2208 V2209))))) (if (shen.pvar? V1812) (do (shen.bindv V1812 () V2208) (let Result (let NewHyp (tl V1807) (do (shen.incinfs) (unify! V V1801 V2208 (freeze (shen.newhyps Vs V2206 NewHyp V2208 V2209))))) (do (shen.unbindv V1812 V2208) Result))) false)))) (if (shen.pvar? V1811) (let A (shen.newpv V2208) (do (shen.bindv V1811 (cons A ()) V2208) (let Result (let NewHyp (tl V1807) (do (shen.incinfs) (unify! V V1801 V2208 (freeze (shen.newhyps Vs V2206 NewHyp V2208 V2209))))) (do (shen.unbindv V1811 V2208) Result)))) false))) (if (shen.pvar? V1810) (do (shen.bindv V1810 : V2208) (let Result (let V1813 (shen.lazyderef (tl V1809) V2208) (if (cons? V1813) (let A (hd V1813) (let V1814 (shen.lazyderef (tl V1813) V2208) (if (= () V1814) (let NewHyp (tl V1807) (do (shen.incinfs) (unify! V V1801 V2208 (freeze (shen.newhyps Vs V2206 NewHyp V2208 V2209))))) (if (shen.pvar? V1814) (do (shen.bindv V1814 () V2208) (let Result (let NewHyp (tl V1807) (do (shen.incinfs) (unify! V V1801 V2208 (freeze (shen.newhyps Vs V2206 NewHyp V2208 V2209))))) (do (shen.unbindv V1814 V2208) Result))) false)))) (if (shen.pvar? V1813) (let A (shen.newpv V2208) (do (shen.bindv V1813 (cons A ()) V2208) (let Result (let NewHyp (tl V1807) (do (shen.incinfs) (unify! V V1801 V2208 (freeze (shen.newhyps Vs V2206 NewHyp V2208 V2209))))) (do (shen.unbindv V1813 V2208) Result)))) false))) (do (shen.unbindv V1810 V2208) Result))) false))) (if (shen.pvar? V1809) (let A (shen.newpv V2208) (do (shen.bindv V1809 (cons : (cons A ())) V2208) (let Result (let NewHyp (tl V1807) (do (shen.incinfs) (unify! V V1801 V2208 (freeze (shen.newhyps Vs V2206 NewHyp V2208 V2209))))) (do (shen.unbindv V1809 V2208) Result)))) false)))) (if (shen.pvar? V1808) (let V (shen.newpv V2208) (let A (shen.newpv V2208) (do (shen.bindv V1808 (cons V (cons : (cons A ()))) V2208) (let Result (let NewHyp (tl V1807) (do (shen.incinfs) (unify! V V1801 V2208 (freeze (shen.newhyps Vs V2206 NewHyp V2208 V2209))))) (do (shen.unbindv V1808 V2208) Result))))) false))) (if (shen.pvar? V1807) (let V (shen.newpv V2208) (let A (shen.newpv V2208) (let NewHyp (shen.newpv V2208) (do (shen.bindv V1807 (cons (cons V (cons : (cons A ()))) NewHyp) V2208) (let Result (do (shen.incinfs) (unify! V V1801 V2208 (freeze (shen.newhyps Vs V2206 NewHyp V2208 V2209)))) (do (shen.unbindv V1807 V2208) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V2212 V2213 V2214) (cond ((= () V2212) V2214) ((and (cons? V2212) (and (cons? V2213) (and (cons? (tl V2213)) (and (= --> (hd (tl V2213))) (and (cons? (tl (tl V2213))) (= () (tl (tl (tl V2213))))))))) (adjoin (cons (hd V2212) (cons : (cons (hd V2213) ()))) (shen.patthyps (tl V2212) (hd (tl (tl V2213))) V2214))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V2219 V2220) (cond ((and (= () V2219) (and (cons? V2220) (and (= --> (hd V2220)) (and (cons? (tl V2220)) (= () (tl (tl V2220))))))) (hd (tl V2220))) ((= () V2219) V2220) ((and (cons? V2219) (and (cons? V2220) (and (cons? (tl V2220)) (and (= --> (hd (tl V2220))) (and (cons? (tl (tl V2220))) (= () (tl (tl (tl V2220))))))))) (shen.result-type (tl V2219) (hd (tl (tl V2220))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V2221 V2222 V2223 V2224 V2225) (let Case (let V1793 (shen.lazyderef V2221 V2224) (if (= () V1793) (do (shen.incinfs) (thaw V2225)) false)) (if (= Case false) (let V1794 (shen.lazyderef V2221 V2224) (if (cons? V1794) (let Pattern (hd V1794) (let Patterns (tl V1794) (let V1795 (shen.lazyderef V2222 V2224) (if (cons? V1795) (let A (hd V1795) (let V1796 (shen.lazyderef (tl V1795) V2224) (if (cons? V1796) (let V1797 (shen.lazyderef (hd V1796) V2224) (if (= --> V1797) (let V1798 (shen.lazyderef (tl V1796) V2224) (if (cons? V1798) (let B (hd V1798) (let V1799 (shen.lazyderef (tl V1798) V2224) (if (= () V1799) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V2223 V2224 (freeze (shen.t*-patterns Patterns B V2223 V2224 V2225)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V2226 V2227 V2228 V2229 V2230) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1770 (shen.lazyderef V2226 V2229) (if (cons? V1770) (let V1771 (shen.lazyderef (hd V1770) V2229) (if (= where V1771) (let V1772 (shen.lazyderef (tl V1770) V2229) (if (cons? V1772) (let P (hd V1772) (let V1773 (shen.lazyderef (tl V1772) V2229) (if (cons? V1773) (let Action (hd V1773) (let V1774 (shen.lazyderef (tl V1773) V2229) (if (= () V1774) (do (shen.incinfs) (cut Throwcontrol V2229 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2228 V2229 (freeze (cut Throwcontrol V2229 (freeze (shen.t*-action Action V2227 (cons (cons P (cons : (cons verified ()))) V2228) V2229 V2230)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1775 (shen.lazyderef V2226 V2229) (if (cons? V1775) (let V1776 (shen.lazyderef (hd V1775) V2229) (if (= shen.choicepoint! V1776) (let V1777 (shen.lazyderef (tl V1775) V2229) (if (cons? V1777) (let V1778 (shen.lazyderef (hd V1777) V2229) (if (cons? V1778) (let V1779 (shen.lazyderef (hd V1778) V2229) (if (cons? V1779) (let V1780 (shen.lazyderef (hd V1779) V2229) (if (= fail-if V1780) (let V1781 (shen.lazyderef (tl V1779) V2229) (if (cons? V1781) (let F (hd V1781) (let V1782 (shen.lazyderef (tl V1781) V2229) (if (= () V1782) (let V1783 (shen.lazyderef (tl V1778) V2229) (if (cons? V1783) (let Action (hd V1783) (let V1784 (shen.lazyderef (tl V1783) V2229) (if (= () V1784) (let V1785 (shen.lazyderef (tl V1777) V2229) (if (= () V1785) (do (shen.incinfs) (cut Throwcontrol V2229 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2227 V2228 V2229 V2230)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1786 (shen.lazyderef V2226 V2229) (if (cons? V1786) (let V1787 (shen.lazyderef (hd V1786) V2229) (if (= shen.choicepoint! V1787) (let V1788 (shen.lazyderef (tl V1786) V2229) (if (cons? V1788) (let Action (hd V1788) (let V1789 (shen.lazyderef (tl V1788) V2229) (if (= () V1789) (do (shen.incinfs) (cut Throwcontrol V2229 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2227 V2228 V2229 V2230)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2226 (cons : (cons V2227 ()))) V2228 V2229 V2230)) Case)) Case)) Case)))))

(defun findall (V2231 V2232 V2233 V2234 V2235) (let B (shen.newpv V2234) (let A (shen.newpv V2234) (do (shen.incinfs) (bind A (gensym shen.a) V2234 (freeze (bind B (set (shen.lazyderef A V2234) ()) V2234 (freeze (shen.findallhelp V2231 V2232 V2233 A V2234 V2235)))))))))

(defun shen.findallhelp (V2236 V2237 V2238 V2239 V2240 V2241) (let Case (do (shen.incinfs) (call V2237 V2240 (freeze (shen.remember V2239 V2236 V2240 (freeze (fwhen false V2240 V2241)))))) (if (= Case false) (do (shen.incinfs) (bind V2238 (value (shen.lazyderef V2239 V2240)) V2240 V2241)) Case)))

(defun shen.remember (V2242 V2243 V2244 V2245) (let B (shen.newpv V2244) (do (shen.incinfs) (bind B (set (shen.deref V2242 V2244) (cons (shen.deref V2243 V2244) (value (shen.deref V2242 V2244)))) V2244 V2245))))



